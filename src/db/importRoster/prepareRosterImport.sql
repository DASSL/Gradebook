--prepareRosterImport.sql - Gradebook

--Kyle Bella, Andrew Figueroa, Zaid Bhujwala, Steven Rollo, Sean Murthy
--Data Science & Systems Lab (DASSL), Western Connecticut State University (WCSU)

--(C) 2017- DASSL. ALL RIGHTS RESERVED.
--Licensed to others under CC 4.0 BY-SA-NC
--https://creativecommons.org/licenses/by-nc-sa/4.0/

--PROVIDED AS IS. NO WARRANTIES EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.


--This script is part of the procedure to import roster from a CSV file
-- it creates some temporary objects (a table and a function) needed for import
-- it should be run before copying the CSV data to the staging table

--The script addSectionMgmt.sql should have been run before running this script


--A temporary staging table for a roster
-- table schema is compatible with the CSV roster file generated by the Banner
-- system at WCSU: consult the README in directory /tests/data for details and
-- some sample rosters
CREATE TEMPORARY TABLE IF NOT EXISTS RosterStaging
(
   LName VARCHAR(50),
   FName VARCHAR(50),
   MName VARCHAR(50),
   ID VARCHAR(50),
   RegStatus VARCHAR(50),
   Level VARCHAR(30),
   Degree VARCHAR(50),
   Program VARCHAR(50),
   Major VARCHAR(50),
   Class VARCHAR(25),
   Credits INTEGER,
   Email VARCHAR(319)
);


--Function to import a roster currently in the rosterStaging table
--param seasonIdentification is a season order, code, or name
-- see function Gradebook.getSeasonOrder(VARCHAR(20))
CREATE OR REPLACE FUNCTION pg_temp.importRoster(year INTEGER,
                                                seasonIdentification VARCHAR(20),
                                                course VARCHAR(8),
                                                sectionNumber VARCHAR(3),
                                                enrollmentDate DATE DEFAULT NULL
                                               )
RETURNS VOID AS
$$

   --add students: if a student already exists, update selected fields
   -- assumes rosters are imported in chronological order so that updating
   -- info of an existing student reflects the most recent info for that student
   INSERT INTO Gradebook.Student(FName, MName, LName, SchoolIssuedID, Email,
                                 Major, Year
                                )
   SELECT r.FName, r.MName, r.LName, r.ID, r.email, r.Major, r.Class
   FROM pg_temp.RosterStaging r
   ON CONFLICT (SchoolIssuedID)
      DO UPDATE SET
         FName = EXCLUDED.FName, MName = EXCLUDED.MName,
         LName = EXCLUDED.LName, Email = EXCLUDED.Email,
         Major = EXCLUDED.Major, Year = EXCLUDED.Year;

   --determine info that is fixed for all enrollments in this import batch
   -- Section ID is fixed based on first four params
   -- Effective enrollment date is NULL if param enrollmentDate is NULL or
   -- is earlier than section start date
   WITH FixedEnrollmentInfo(SectionID, StartDate) AS
   (
      SELECT ID, (CASE WHEN $5 > N.StartDate THEN $5 ELSE NULL END)
      FROM Gradebook.getSection($1, Gradebook.getSeasonOrder($2), $3, $4) N
   )
   --record students as enrollees in the section: ignore conflicts
   INSERT INTO Gradebook.Enrollee(Student, Section, DateEnrolled, YearEnrolled,
                                  MajorEnrolled
                                 )
      SELECT S.ID, f.SectionID, f.StartDate, r.Class, r.Major
      FROM FixedEnrollmentInfo f,
           pg_temp.RosterStaging r
           JOIN Gradebook.Student S ON r.ID = S.SchoolIssuedID
      ON CONFLICT DO NOTHING;

$$ LANGUAGE SQL;
